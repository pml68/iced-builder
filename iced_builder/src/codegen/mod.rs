use rust_format::{Config, Edition, Formatter, RustFmt};

use crate::types::{
    rendered_element::{container, row, svg, text, RenderedElement},
    ElementName,
};

impl RenderedElement {
    fn props_codegen(&self) -> String {
        let mut props_string = String::new();

        for (k, v) in self.props.clone() {
            if let Some(value) = v {
                props_string = format!("{props_string}.{k}({value})");
            }
        }

        props_string
    }

    fn codegen(&self) -> (String, String) {
        let mut imports = String::new();
        let mut view = String::new();
        let props = self.props_codegen();

        let mut elements = String::new();

        if let Some(els) = &self.child_elements {
            for element in els {
                let (c_imports, children) = element.codegen();
                imports = format!("{imports}{c_imports}");
                elements = format!("{elements}{},", children);
            }
        }

        match &self.name {
            ElementName::Container => {
                imports = format!("{imports}container,");
                view = format!("{view}\ncontainer({elements}){props}");
            }
            ElementName::Row => {
                imports = format!("{imports}row,");
                view = format!("{view}\nrow![{elements}]{props}");
            }
            ElementName::Column => {
                imports = format!("{imports}column,");
                view = format!("{view}\ncolumn![{elements}]{props}");
            }
            ElementName::Text(string) => {
                imports = format!("{imports}text,");
                view = format!(
                    "{view}\ntext(\"{}\"){props}",
                    if *string == String::new() {
                        "New Text"
                    } else {
                        string
                    }
                );
            }
            ElementName::Button(string) => {
                imports = format!("{imports}button,");
                view = format!(
                    "{view}\nbutton(\"{}\"){props}",
                    if *string == String::new() {
                        "New Button"
                    } else {
                        string
                    }
                );
            }
            ElementName::Image(path) => {
                imports = format!("{imports}image,");
                view = format!("{view}\nimage(\"{path}\"){props}");
            }
            ElementName::SVG(path) => {
                imports = format!("{imports}svg,");
                view = format!("{view}\nsvg(\"{path}\"){props}");
            }
        }

        (imports, view)
    }

    pub fn app_code(
        &self,
        title: &str,
        theme: Option<iced::Theme>,
    ) -> Result<String, Box<dyn std::error::Error>> {
        let (imports, view) = self.codegen();
        let mut app_code = format!("use iced::{{widget::{{{imports}}},Sandbox,Settings,Element}};");

        app_code = format!(
            r#"// Automatically generated by iced Builder
            {app_code}

        fn main() -> iced::Result {{
            App::run(Settings::default())
        }}

        struct App;

        impl Sandbox for App {{
            type Message = ();

            fn new() -> Self {{
                Self {{}}
            }}

            fn title(&self) -> String {{
                "{title}".into()
            }}

            fn theme(&self) -> iced::Theme {{
                iced::Theme::{}
            }}

            fn update(&mut self, message: Self::Message) {{

            }}

            fn view(&self) -> Element<Self::Message> {{
                {view}.into()
            }}
        }}"#,
            if let Some(c) = theme {
                c.to_string().replace(' ', "")
            } else {
                "default()".to_owned()
            }
        );
        let config = Config::new_str()
            .edition(Edition::Rust2021)
            .option("trailing_comma", "Never")
            .option("imports_granularity", "Crate");
        let rustfmt = RustFmt::from_config(config);
        Ok(rustfmt.format_str(app_code)?)
    }

    pub fn test() -> RenderedElement {
        let text1 = text("wow").option("height", "120.5").option("width", "230");

        let element = container(row(vec![
            text1,
            text("heh"),
            svg("/mnt/drive_d/git/obs-website/src/lib/assets/bars-solid.svg"),
        ]));

        element
    }
}
