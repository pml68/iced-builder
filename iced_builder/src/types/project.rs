use rust_format::{Config, Edition, Formatter, RustFmt};
use std::path::{Path, PathBuf};

use iced::Theme;
use serde::{Deserialize, Serialize};

use crate::Error;

use super::rendered_element::RenderedElement;

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Project {
    pub title: Option<String>,
    pub theme: Option<String>,
    pub element_tree: Option<RenderedElement>,
}

impl Project {
    pub fn new() -> Self {
        Self {
            title: None,
            theme: None,
            element_tree: None,
        }
    }

    pub fn get_theme(&self) -> Theme {
        match &self.theme {
            Some(theme) => match theme.as_str() {
                "Light" => Theme::Light,
                "Dark" => Theme::Dark,
                "Dracula" => Theme::Dracula,
                "Nord" => Theme::Nord,
                "Solarized Light" => Theme::SolarizedLight,
                "Solarized Dark" => Theme::SolarizedDark,
                "Gruvbox Light" => Theme::GruvboxLight,
                "Gruvbox Dark" => Theme::GruvboxDark,
                "Catppuccin Latte" => Theme::CatppuccinLatte,
                "Catppuccin FrappÃ©" => Theme::CatppuccinFrappe,
                "Catppuccin Macchiato" => Theme::CatppuccinMacchiato,
                "Catppuccin Mocha" => Theme::CatppuccinMocha,
                "Tokyo Night" => Theme::TokyoNight,
                "Tokyo Night Storm" => Theme::TokyoNightStorm,
                "Tokyo Night Light" => Theme::TokyoNightLight,
                "Kanagawa Wave" => Theme::KanagawaWave,
                "Kanagawa Dragon" => Theme::KanagawaDragon,
                "Kanagawa Lotus" => Theme::KanagawaLotus,
                "Moonfly" => Theme::Moonfly,
                "Nightfly" => Theme::Nightfly,
                "Oxocarbon" => Theme::Oxocarbon,
                "Ferra" => Theme::Ferra,
                _ => Theme::Dark,
            },
            None => Theme::Dark,
        }
    }

    pub async fn from_file() -> Result<(PathBuf, Self), Error> {
        let picked_file = rfd::AsyncFileDialog::new()
            .set_title("Open a JSON file...")
            .add_filter("*.JSON, *.json", &["JSON", "json"])
            .pick_file()
            .await
            .ok_or(Error::DialogClosed)?;

        let path = picked_file.path().to_owned();

        let contents = tokio::fs::read_to_string(&path).await?;
        let element: Self = serde_json::from_str(&contents)?;

        Ok((path, element))
    }

    pub async fn write_to_file(self, path: Option<PathBuf>) -> Result<PathBuf, Error> {
        let path = if let Some(p) = path {
            p
        } else {
            rfd::AsyncFileDialog::new()
                .set_title("Save to JSON file...")
                .add_filter("*.JSON, *.json", &["JSON", "json"])
                .save_file()
                .await
                .as_ref()
                .map(rfd::FileHandle::path)
                .map(Path::to_owned)
                .ok_or(Error::DialogClosed)?
        };

        let contents = serde_json::to_string(&self.clone())?;
        tokio::fs::write(&path, contents).await?;

        Ok(path)
    }

    pub fn app_code(&self) -> Result<String, Error> {
        match self.element_tree {
            Some(ref element_tree) => {
                let (imports, view) = element_tree.codegen();
                let mut app_code = format!("use iced::{{widget::{{{imports}}},Element}};");

                app_code = format!(
                    r#"// Automatically generated by iced Builder
                    {app_code}

                    fn main() -> iced::Result {{
                        iced::application("{}", State::update, State::view).theme(iced::Theme::{}).run()
                    }}

                    #[derive(Default)]
                    struct State;

                    #[derive(Debug, Clone)]
                    enum Message {{}}

                    impl State {{
                        fn update(&mut self, _message: Message) {{}}

                        fn view(&self) -> Element<Message> {{
                            {view}.into()
                        }}
                    }}"#,
                    match self.title {
                        Some(ref t) => t,
                        None => "New app",
                    },
                    self.get_theme().to_string().replace(" ", "")
                );
                let config = Config::new_str()
                    .edition(Edition::Rust2021)
                    .option("trailing_comma", "Never")
                    .option("imports_granularity", "Crate");
                let rustfmt = RustFmt::from_config(config);
                Ok(rustfmt.format_str(app_code)?)
            }
            None => Err("No element tree present".into()),
        }
    }
}
