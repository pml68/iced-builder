use std::path::{Path, PathBuf};

use iced::Theme;
use rust_format::{Config, Edition, Formatter, RustFmt};
use serde::{Deserialize, Serialize};

use super::rendered_element::RenderedElement;
use crate::theme::theme_from_str;
use crate::{Error, Result};

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Project {
    pub title: Option<String>,
    pub theme: Option<String>,
    pub element_tree: Option<RenderedElement>,
}

impl Default for Project {
    fn default() -> Self {
        Self::new()
    }
}

impl Project {
    pub fn new() -> Self {
        Self {
            title: None,
            theme: None,
            element_tree: None,
        }
    }

    pub fn get_theme(&self, config: &crate::config::Config) -> Theme {
        match &self.theme {
            Some(theme) => theme_from_str(Some(config), theme),
            None => Theme::Dark,
        }
    }

    pub async fn from_path(path: PathBuf) -> Result<(PathBuf, Self)> {
        let contents = tokio::fs::read_to_string(&path).await?;
        let element: Self = serde_json::from_str(&contents)?;

        Ok((path, element))
    }

    pub async fn from_file() -> Result<(PathBuf, Self)> {
        let picked_file = rfd::AsyncFileDialog::new()
            .set_title("Open a JSON file...")
            .add_filter("*.json, *.JSON", &["json", "JSON"])
            .pick_file()
            .await
            .ok_or(Error::DialogClosed)?;

        let path = picked_file.path().to_owned();

        Self::from_path(path).await
    }

    pub async fn write_to_file(self, path: Option<PathBuf>) -> Result<PathBuf> {
        let path = if let Some(p) = path {
            p
        } else {
            rfd::AsyncFileDialog::new()
                .set_title("Save to JSON file...")
                .add_filter("*.json, *.JSON", &["json", "JSON"])
                .save_file()
                .await
                .as_ref()
                .map(rfd::FileHandle::path)
                .map(Path::to_owned)
                .ok_or(Error::DialogClosed)?
        };

        let contents = serde_json::to_string(&self)?;
        tokio::fs::write(&path, contents).await?;

        Ok(path)
    }

    pub fn app_code(&self, config: &crate::config::Config) -> Result<String> {
        match self.element_tree {
            Some(ref element_tree) => {
                let (imports, view) = element_tree.codegen();
                let mut app_code =
                    format!("use iced::{{widget::{{{imports}}},Element}};");

                app_code = format!(
                    r#"// Automatically generated by iced Builder
                    {app_code}

                    fn main() -> iced::Result {{
                        iced::application("{}", State::update, State::view).theme(State::theme).run()
                    }}

                    #[derive(Default)]
                    struct State;

                    #[derive(Debug, Clone)]
                    enum Message {{}}

                    impl State {{
                        fn update(&mut self, _message: Message) {{}}

                        fn theme(&self) -> iced::Theme {{
                            iced::Theme::{}
                        }}

                        fn view(&self) -> Element<Message> {{
                            {view}.into()
                        }}
                    }}"#,
                    match self.title {
                        Some(ref t) => t,
                        None => "New app",
                    },
                    self.get_theme(config).to_string().replace(" ", "")
                );
                let config = Config::new_str()
                    .edition(Edition::Rust2021)
                    .option("trailing_comma", "Never")
                    .option("imports_granularity", "Crate");
                let rustfmt = RustFmt::from_config(config);
                Ok(rustfmt.format_str(app_code)?)
            }
            None => Err("No element tree present".into()),
        }
    }
}
